# romaklayt.DynamicFilter

Simple filter for .net WebApi that enables your endpoint to query your requests by url.

It provides ways to query, order and page your webapi and mvc.

# .Net Core and .Net

First, download the packages into your project from nuget

```batch
nuget install romaklayt.DynamicFilter.Extensions
nuget install romaklayt.DynamicFilter.Binder.Net
```

and, if you need, add to your *ConfigureServices* **Startup.cs** class for register value provider (JSON) for body JSON
POST request support (providers for form-data, x-www-form-urlencoded work them by default)

```C#
services.AddControllers(options => options.ValueProviderFactories.Add(new JsonBodyValueProviderFactory()));
```

# .Net Framework (>=4.6.2)

First, download the packages into your project from nuget

```batch
nuget install romaklayt.DynamicFilter.Extensions
```

If you need to add a filter to the **web api** controller use the package

```batch
nuget install romaklayt.DynamicFilter.Binder.NetFramework.WebApi
```

and, if you need, add to your **WebApiConfig** class for register value providers (form-data, x-www-form-urlencoded and
JSON) for body POST request

```C#
config.AddDynamicFilterProviders();
```

If you need to add a filter to the **MVC** controller use the package

```batch
nuget install romaklayt.DynamicFilter.Binder.NetFramework.Mvc
```

and, if you need, add to your *Application_Start* **Global.asax.cs** class for register value providers (form-data,
x-www-form-urlencoded and JSON) for body POST request

```C#
DynamicFilterProviders.AddProviders();
```

If you need to use DynamicFilter with IAsyncEnumerable or IAsyncQueryable use the package

```batch
nuget install romaklayt.DynamicFilter.Extensions.Async
```

After downloaded, go to your webapi and create an *get* or *post* endpoint receiving ```IDynamicComplex``` as
parameter.

```C#
[HttpGet]
public Task<List<User>> Get([FromQuery] IDynamicComplex filter)
```

Now you can query your endpoint with the DynamicFilter properties. Check *"tests"* folder on the Api projects for
examples.

```C#
[HttpGet]
public Task<List<User>> Get([FromQuery] IDynamicComplex filter)
{
    return users.Apply(filter).ToList();
}
```

DynamicFilter.Parser will transform your URI Queries into .Net Expressions. That way, you can use these expressions to
filter your values into your database repository.

## Simple Filter

You can use a **DynamicComplexModel** model for filtering. A **DynamicFilterModel** model without additional properties
is also available.

```C#
public Task<List<User>> Get([FromQuery] IDynamicComplex filter) #or DynamicFilterModel
{
    return users.Apply(filter).ToList(); #ApplyFilter for DynamicFilterModel
}
```

Example Uri:

```http
GET http://url?filter=name==Bruno
```

Expression generated by Uri:

```C#
x => x.Name == "Bruno"
```

Filters are also supported for nested collections.

```http
GET http://url?filter=roles.name==admin
```

Your request will be converted to:

```C#
users.Where(x => x.Roles.Any(y => y.Name == "admin"))
```

The parser supports the count property for the collection, you can use it as a regular collection property:

```http
GET http://url?filter=roles.count==1
```

If you need to filter values by default for the value type, use **\default**:

```http
GET http://url?filter=roles.name==\default
```

## Complex Filter

Boolean operators &&(and) and ||(or) are supported.

Example Uri:

```http
GET http://url?filter=name==Bruno&&lastname@=r&&age>=27
```

Since version 2.0 more complex filters are available.
You can use brackets to create more complex expressions.

```http
GET http://url?filter=(name==Bruno&&lastname@=r)||(age>=27)
```

```http
GET http://url?filter=(name==Bruno&&lastname@=r)||(age>=27&&name==Bruno)
```

You can nest multiple parentheses to create complex expressions.

```http
GET http://url?filter=((name==Bruno&&lastname@=r)||(age>=27))&&roles.name==Admin
```

## Attention!

For correct parsing of the filter, when using brackets, enclose all logical elements in brackets, for example:

### Not correct

```http
GET http://url?filter=((name==Bruno&&lastname@=r)||age>=27)&&roles.name==Admin
```

### Correct (age>=27 in brackets)

```http
GET http://url?filter=((name==Bruno&&lastname@=r)||(age>=27))&&roles.name==Admin
```

## Nested Filer

Example Uri:

```http
GET http://url?filter=address.number==23
```

Expression generated by Uri:

```C#
x => x.Address.Number == 23
```

# Ordering

You can also order your queries via DynamicFilter. You simply need to add an order parameter on your query, where you
specify the property you'll use for order.

```http
GET http://url?filter=name==Bruno&order=name
```

Default order type is Ascending. You can adding a `-` before the name switches to sorting descendingly..

```http
GET http://url?filter=name==Bruno&order=name

GET http://url?filter=name==Bruno&order=-name
```

To sort by multiple properties:

```http
GET http://url?filter=name==Bruno&order=name,firstname

GET http://url?filter=name==Bruno&order=-name,-firstname
```

If you do not specify the sort type, **asc** is used by default.

On your DynamicFilter object received on the endpoint, you'll get the orderType as an Enum, this way you can order by
the type specified on enum.

```C#
public Task<List<User>> Get([FromQuery] IDynamicComplex filter)
{
    return users.Apply(filter).ToList();
}
```

# Pagging

```http
GET http://url?filter=name@=*b&order=name&page=1&pagesize=10
```

In romaklayt.DynamicFilter.Extensions.* there is a method of expanding the **ToPageModel** which returns *PageModel*
with *info about page* and your *filtered data*.

```C#
var page = users.ToPageModel(filterModel);
```

The PageModel is built on top of the List<T> so to add page information to the server response you need to add an
AddPageInfoFilter which will write the page information to the headers.

```C#
services.AddControllers(options =>
        {
            options.Filters.Add(new PageInfoWriter());
        });
```

If you no need page info, you simply needs to add the parameters page and pagesize on your get request.

```C#
result = result.ApplyFilter(filter); #page mode without additional info
```

If you specify the page number and size in the filter model, pagination is disabled when using **ApplyFilter**. You can
also disable pagination by forcibly calling:

```C#
result = result.ApplyFilter(filter, false); #only filtering without pagination
```

Example:

```C#
[HttpGet("page")]
public async Task<PageModel<User>> GetPage([FromQuery] IDynamicComplex filterModel)
{
    return Data.Users.ToPageModel(filterModel);
}
```

# Select

To select, you simply needs to add the parameter select with the properties you want to select from. It will render
either an linq select and a plain string select.

```http
GET http://url?select=name,age
```

If you select a nested property, from default, the properties from the root model will be ignored, to select all the
root properties, use the word root.

```http
GET http://url?select=address.zip,root #select Address.Zip and all root properties
```

If you need to select properties from *only one model* (the GetById method, for example), you can also use the method **
ApplyFilter**.

```C#
[HttpGet("{id}")]
public async Task<object> GetById([FromQuery] IDynamicSelect dynamicSelectModel, Guid id)
{
    return await Data.Users.ApplySelect(dynamicSelectModel).DynamicFirstOfDefault("Id", id);
}
```

# Filter operator support

| Operator | Meaning                             |
|----------|-------------------------------------|
| `==`     | Equals                              |
| `>`      | Greater than                        |
| `<`      | Less than                           |
| `>=`     | Greater than or equal to            |
| `<=`     | Less than or equal to               |
| `@=`     | Contains                            |
| `_=`     | Starts with                         |
| `_-=`    | Ends with                           |
| `@=*`    | Case-insensitive string Contains    |
| `_=*`    | Case-insensitive string Starts with |
| `_-=*`   | Case-insensitive string Ends with   |
| `==*`    | Case-insensitive string Equals      |

### All operators support negation, you need to put **"!"** before the operator (e.g. **!==** for Equals) 
