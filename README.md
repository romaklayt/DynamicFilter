# romaklayt.DynamicFilter

Simple filter for .net WebApi that enables your endpoint to query your requests by url.

It provides ways to query, order and page your webapi and mvc.

# .Net Core and .Net

First, download the packages into your project from nuget

```batch
nuget install romaklayt.DynamicFilter.Extensions
nuget install romaklayt.DynamicFilter.Binder.Net
```

and, if you need, add to your *ConfigureServices* **Startup.cs** class for register value provider (JSON) for body JSON
POST request support (providers for form-data, x-www-form-urlencoded work them by default)

```C#
services.AddControllers(options => options.ValueProviderFactories.Add(new JsonBodyValueProviderFactory()));
```

# .Net Framework (>=4.6.1)

First, download the packages into your project from nuget

```batch
nuget install romaklayt.DynamicFilter.Extensions
```

If you need to add a filter to the **web api** controller use the package

```batch
nuget install romaklayt.DynamicFilter.Binder.NetFramework.WebApi
```

and, if you need, add to your **WebApiConfig** class for register value providers (form-data, x-www-form-urlencoded and
JSON) for body POST request

```C#
config.AddDynamicFilterProviders();
```

If you need to add a filter to the **MVC** controller use the package

```batch
nuget install romaklayt.DynamicFilter.Binder.NetFramework.Mvc
```

and, if you need, add to your *Application_Start* **Global.asax.cs** class for register value providers (form-data,
x-www-form-urlencoded and JSON) for body POST request

```C#
DynamicFilterProviders.AddProviders();
```

If you need to use DynamicFilter with IAsyncEnumerable or IAsyncQueryable use the package

```batch
nuget install romaklayt.DynamicFilter.Extensions.Async
```

After downloaded, go to your webapi and create an *get* or *post* endpoint receiving ```DynamicComplexModel``` as
parameter.

```C#
[HttpGet]
public Task<List<User>> Get(DynamicComplexModel filter)
```

Now you can query your endpoint with the DynamicFilter properties. Check *"tests"* folder on the Api projects for
examples.

```C#
[HttpGet]
public Task<List<User>> Get(DynamicComplexModel filter)
{
    return users.Apply(filter).ToList();
}
```

DynamicFilter.Parser will transform your URI Queries into .Net Expressions. That way, you can use these expressions to
filter your values into your database repository.

## Simple Filter

You can use a **DynamicComplexModel** model for filtering. A **DynamicFilterModel** model without additional properties
is also available.

```C#
public Task<List<User>> Get(DynamicComplexModel filter) #or DynamicFilterModel
{
    return users.Apply(filter).ToList(); #ApplyFilter for DynamicFilterModel
}
```

Example Uri:

```http
GET http://url?filter=name==Bruno
```

Expression generated by Uri:

```C#
x => x.Name == "Bruno"
```

Filters are also supported for nested collections.

```http
GET http://url?filter=roles.name==admin
```

Your request will be converted to:

```C#
users.Where(x => x.Roles.Any(y => y.Name == "admin"))
```

The parser supports the count property for the collection, you can use it as a regular collection property:

```http
GET http://url?filter=roles.count==1
```

If you need to filter values by default for the value type, use **\default**:

```http
GET http://url?filter=roles.name==\default
```

## Complex Filter

Example Uri:

```http
GET http://url?filter=name=Bruno,lastname%r,age>=27
```

Expression generated by Uri:

```C#
x => x.Name == "Bruno" 
  && x.LastName.ToLower().Contains("r") 
  && x.Age >= 27
```

You can add conditions to your filter sorting your filters with a comma (,), as shown above.

## Nested Filer

Example Uri:

```http
GET http://url?filter=address.number==23
```

Expression generated by Uri:

```C#
x => x.Address.Number == 23
```

## Multiple filter values for a single property

Such a query will select all entities whose age corresponds to 23, 28 or 27 years

```http
GET http://url?filter=age==[23||28||37] #
```

To recognize the query, you need to put the values in square brackets *[ and ]*. The values inside the brackets must be
separated by **'|' (which will be equivalent to or) or '&' (which will be equivalent to and)**. Comparison operators are
available the same as by default.

# Ordering

You can also order your queries via DynamicFilter. You simply need to add an order parameter on your query, where you
specify the property you'll use for order.

```http
GET http://url?filter=name==Bruno&order=name
```

Default order type is Ascending. You can adding a `-` before the name switches to sorting descendingly..

```http
GET http://url?filter=name==Bruno&order=name

GET http://url?filter=name==Bruno&order=-name
```

To sort by multiple properties:

```http
GET http://url?filter=name==Bruno&order=name,firstname

GET http://url?filter=name==Bruno&order=-name,firstname
```

If you do not specify the sort type, **asc** is used by default.

On your DynamicFilter object received on the endpoint, you'll get the orderType as an Enum, this way you can order by
the type specified on enum.

```C#
public Task<List<User>> Get([FromQuery] DynamicComplexModel filter)
{
    return users.Apply(filter).ToList();
}
```

# Pagging

```http
GET http://url?filter=name@=*b&order=name&page=1&pagesize=10
```

In romaklayt.DynamicFilter.Extensions and romaklayt.DynamicFilter.Extensions.Async there is a method of expanding the **
ToPageModel** which returns *PageModel* with *info about page* and your *filtered data*.

```C#
var page = users.ToPageModel(filterModel);
```

If you no need page info, you simply needs to add the parameters page and pagesize on your get request.

```C#
result = result.ApplyFilter(filter); #page mode without additional info
```

If you specify the page number and size in the filter model, pagination is disabled when using **ApplyFilter**. You can
also disable pagination by forcibly calling:

```C#
result = result.ApplyFilter(filter, false); #only filtering without pagination
```

Example:

```C#
[HttpGet("page")]
public async Task<PageModel<User>> GetPage([FromQuery] DynamicComplexModel filterModel)
{
    return Data.Users.ToPageModel(filterModel);
}
```

# Select

To select, you simply needs to add the parameter select with the properties you want to select from. It will render
either an linq select and a plain string select.

```http
GET http://url?select=name,age
```

If you select a nested property, from default, the properties from the root model will be ignored, to select all the
root properties, use the word root.

```http
GET http://url?select=address.zip,root #select Address.Zip and all root properties
```

If you need to select properties from *only one model* (the GetById method, for example), you can also use the method **
ApplyFilter**.

```C#
[HttpGet("{id}")]
public async Task<object> GetById([FromQuery] DynamicSelectModel dynamicSelectModel, Guid id)
{
    return await Data.Users.ApplySelect(dynamicSelectModel).DynamicFirstOfDefault("Id", id);
}
```

# Filter operator support

| Operator   | Meaning                  |
|------------|--------------------------|
| `==`       | Equals                   |
| `>`        | Greater than             |
| `<`        | Less than                |
| `>=`       | Greater than or equal to |
| `<=`       | Less than or equal to    |
| `@=`       | Contains                 |
| `_=`       | Starts with              |
| `_-=`      | Ends with                |
| `@=*`      | Case-insensitive string Contains |
| `_=*`      | Case-insensitive string Starts with |
| `_-=*`     | Case-insensitive string Ends with |
| `==*`      | Case-insensitive string Equals |

### All operators support negation, you need to put **"!"** before the operator (e.g. **!==** for Equals) 
