# romaklayt.DynamicFilter

Simple filter for .net WebApi that enables your endpoint to query your requests by url.

It provides ways to query, order and page your webapi and mvc.

# .Net Core and .Net

First, download the packages into your project from nuget

```batch
nuget install romaklayt.DynamicFilter.Extensions
nuget install romaklayt.DynamicFilter.Binder.Net
```

and, if you need, add to your *ConfigureServices* **Startup.cs** class for register value provider (JSON) for body JSON
POST request support (providers for form-data, x-www-form-urlencoded work them by default)

```C#
services.AddControllers(options => options.ValueProviderFactories.Add(new JsonBodyValueProviderFactory()));
```

# .Net Framework (>=4.6.1)

First, download the packages into your project from nuget

```batch
nuget install romaklayt.DynamicFilter.Extensions
```

If you need to add a filter to the **web api** controller use the package

```batch
nuget install romaklayt.DynamicFilter.Binder.NetFramework.WebApi
```

and, if you need, add to your **WebApiConfig** class for register value providers (form-data, x-www-form-urlencoded and
JSON) for body POST request

```C#
config.AddDynamicFilterProviders();
```

If you need to add a filter to the **MVC** controller use the package

```batch
nuget install romaklayt.DynamicFilter.Binder.NetFramework.Mvc
```

and, if you need, add to your *Application_Start* **Global.asax.cs** class for register value providers (form-data, x-www-form-urlencoded and JSON) for body POST request

```C#
DynamicFilterProviders.AddProviders();
```

If you need to use DynamicFilter with IAsyncEnumerable or IAsyncQueryable use the package

```batch
nuget install romaklayt.DynamicFilter.Extensions.Async
```

After downloaded, go to your webapi and create an *get* or *post* endpoint receiving ```DynamicComplexModel``` as parameter.

```C#
[HttpGet]
public Task<List<User>> Get(DynamicComplexModel filter)
```

Now you can query your endpoint with the DynamicFilter properties. Check *"tests"* folder on the Api projects for examples.

```C#
[HttpGet]
public Task<List<User>> Get(DynamicComplexModel filter)
{
    var result = this.users.UseFilter(filter);

    return Task.FromResult(result.ToList());
}
```

DynamicFilter.Parser will transform your URI Queries into .Net Expressions. That way, you can use these expressions to filter your values into your database repository.

## Simple Query

You can use a **DynamicComplexModel** model for filtering. A **DynamicFilterModel** model without additional properties is also available.

```C#
public Task<List<User>> Get(DynamicComplexModel filter) #or DynamicFilterModel
{
    var result = users.UseFilter(filter);

    return Task.FromResult(result.ToList());
}
```

Example Uri:

```http
GET http://url?query=name=Bruno
```

Expression generated by Uri:

```C#
x => x.Name == "Bruno"
```

Filters are also supported for nested collections.

```http
GET http://url?query=roles.name=admin
```

Your request will be converted to:

```C#
users.Where(x => x.Roles.Any(y => y.Name == "admin"))
```

## Complex Query

Example Uri:

```http
GET http://url?query=name=Bruno,lastname%r,age>=27
```

Expression generated by Uri:

```C#
x => x.Name == "Bruno" 
  && x.LastName.ToLower().Contains("r") 
  && x.Age >= 27
```

You can add conditions to your query sorting your filters with a comma (,), as shown above.

## Nested Query

Example Uri:

```http
GET http://url?query=address.number=23
```

Expression generated by Uri:

```C#
x => x.Address.Number == 23
```

# Ordering

You can also order your queries via DynamicFilter. You simply need to add an order parameter on your query, where you specify the property you'll use for order.

```http
GET http://url?query=name=Bruno&order=name
```

Default order type is Ascending. You can specify the order type with an equals (=) *Asc* or *Desc* after the property.

```http
GET http://url?query=name=Bruno&order=name=Asc

GET http://url?query=name=Bruno&order=name=Desc
```

On your DynamicFilter object received on the endpoint, you'll get the orderType as an Enum, this way you can order by the type specified on enum.

```C#
public Task<List<User>> Get(DynamicComplexModel filter)
{
    var result = users.UseFilter(filter);

    return Task.FromResult(result.ToList());
}
```

# Pagging

```http
GET http://url?query=name%b&order=name&page=1&pagesize=10
```

In romaklayt.DynamicFilter.Extensions and romaklayt.DynamicFilter.Extensions.Async there is a method of expanding the **ToPagedList** which returns *PageModel* with *info about page* and your *filtered data*.

```C#
var page = users.ToPagedList(filterModel);
```

If you no need page info, you simply needs to add the parameters page and pagesize on your get request.

```C#
result = result.UseFilter(filter); #page mode without info
```

If you specify the page number and size in the filter model, pagination is disabled when using **UseFilter**. You can also disable pagination by forcibly calling:

```C#
result = result.UseFilter(filter, false); #only filtering without pagination
```

Example:

```C#
[HttpGet("page")]
public async Task<PageModel<User>> GetPage(DynamicComplexModel filterModel)
{
    var filteredUsers = await Data.Users.UseFilter(filterModel);
    return await filteredUsers.ToPagedList(filterModel);
}
```

# Select

To select, you simply needs to add the parameter select with the properties you want to select from. It will render either an linq select and a plain string select.

```http
GET http://url?select=name,age
```

If you select a nested property, from default, the properties from the root model will be  ignored, to select all the root properties, use the word root.

```http
GET http://url?select=address.zip,root #select Address.Zip and all root properties
```

If you don't want to send model properties that are not included in your **Select** request, you can use the *GetOnlySelectedProperties* extension method, which will render you only the selected properties. Example:

```C#
result = items.UseFilter(filter).Result.GetOnlySelectedProperties(filterModelModel);
```

If you need to select properties from *only one model* (the GetById method, for example), you can also use the method **UseFilter**.

```C#
[HttpGet("{id}")]
public async Task<object> GetById(DynamicSelectModel dynamicSelectModel, Guid id)
{
    var user = await Data.Users.UseSelect(dynamicSelectModel).FirstOrDefaultAsync(user => user.Id == id);
    return user.RenderOnlySelectedProperties(dynamicSelectModel);
}
```

# Filter operator support

- Equals (=)

```http
GET http://url?query=name=Bruno
```

- Contains Invariant Case (%)

```http
GET http://url?query=name%b
```

- Contains Case Sensitive (%%)

```http
GET http://url?query=name%%B
```

- GreaterThan (>)

```http
GET http://url?query=age>15
```

- GreaterOrEqual (>=)

```http
GET http://url?query=age>=15
```

- LessThan (<)

```http
GET http://url?query=age<15
```

- LessOrEqual (<=)

```http
GET http://url?query=age<=15
```

- NotEquals (!=)

```http
GET http://url?query=age!=15
```
